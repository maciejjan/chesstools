#!/usr/bin/perl

use Curses;
use File::Temp qw/tempfile/;
use Try::Tiny;
use utf8;

use Chess::Rep;
use Chess::PGN::Parse;

our %GAME;
our %PROMPT;
our $BOARD;

our %LIST = (
  sel => 0,
  top => 0,
);

our %TREE = (
  sel => 0,
  root => undef,
  list => undef,
);

our @LIST_FIELDS = ("No", "White", "Black", "Year", "Result", "ECO");

our $BOARDCMD = "drawboard";
our $YANKCMD = "xclip -i";

if (($#ARGV < 0) || ($ARGV[0] eq "-h") || ($ARGV[0] eq "--help")) {
  die "usage: pgnvi PGN_FILE";
}

our $FILENAME = $ARGV[0];

$pgn = new Chess::PGN::Parse "$FILENAME"
  || die "Could not open file: $FILENAME";
$GAMES = $pgn->read_all();

# TODO (for v 0.2)
# - correct the coding style
#   - last element of an array: $arr_ref->[-1];
#   - iterating over arrays: foreach instead of counters
#   - subroutine parameters: use @_ instead of shift
#   - refactor larger subroutines (especially *_keypress)
# - comments and variants
#     'V' deletes the current variant (if not main line) and returns to the
#         main line
# - identify all cases of game_reset_variant
# - NAGs
# ===================================
# later:
# - improvements in the tree view:
#   - compress nodes with only one child
# - list & tree view
#   - searching
#   - filtering
# - scrolling of the move list
# - implement "redo"
# TODO metadata editing mode
# FIXME bugs:
# - if a board window is closed, pgnvi still tries to write to the pipe and
#   crashes

sub yank {
  my $arg = shift;
  if (open(my $pipe, "|-:encoding(UTF-8)", $YANKCMD)) {
    print $pipe $arg;
    close($pipe);
  }
}

sub move_number {
  my $mn = shift;
  return int($mn/2+0.5) . "." . ($mn % 2 == 0 ? ".." : "");
}

sub print_game {
  my $fh = shift;
  my $game = shift;
  for my $key (keys %$game) {
    if (($key =~ /^[A-Z].*/) && ($key !~ /Game.*/)) {
      print $fh "[$key \"$game->{$key}\"]\n";
    }
  }
  print $fh "\n";
  print $fh $game->{Game}."\n\n";
}

sub save {
  my $filename = shift;
  open $fh, "+>", $filename;
  for my $game (@$GAMES) {
    print_game $fh, $game;
  }
  close $fh;
}

sub format_game {
  my $game = shift;
  my $year = substr $game->{Date}, 0, 4;
  return $game->{White}." — ".$game->{Black}." ($year) — ".$game->{Result};
}

sub get_field_for_game {
  my ($field, $idx) = @_;
  if ($field eq "Year") {
    return substr $GAMES->[$idx]->{Date}, 0, 4;
  } elsif ($field eq "No") {
    return $idx+1;
  } elsif ($field eq "keys") { # for debug purposes only
    return join(",",(keys %{$GAMES->[$idx]}));
  } elsif ($field eq "moves") { # for debug purposes only
    return join(",",@{$GAMES->[$idx]->{GameMoves}});
  } else {
    return $GAMES->[$idx]->{$field};
  }
}

sub format_list {
  my ($start, $end) = @_;

  $result = [];
  $fieldlen = ();
  for my $field (@LIST_FIELDS) {
    for (my $i = $start; $i <= $end; $i++) {
      my $l = length(get_field_for_game($field, $i));
      if ((!defined($fieldlen{$field})) || ($fieldlen{$field} < $l)) {
        $fieldlen{$field} = $l;
      }
    }
  }
  for (my $i = $start; $i <= $end; $i++) {
    my @str = ();
    for my $field (@LIST_FIELDS) {
      my $val = get_field_for_game($field, $i);
      push @str, $val;
      for (my $j = 0; $j < ($fieldlen{$field} - length $val)+2; $j++) {
        push @str, " ";
      }
    }
    push @$result, (join "", @str);
  }
  return $result;
}

sub setup_curses {
  my $win = shift;
  initscr;
  raw;
  keypad($win, 1);
  noecho();
  curs_set(0);

  start_color;
  use_default_colors;
}

# BOARD

sub board_open {
  open $BOARD, "|-", $BOARDCMD;
  autoflush $BOARD 1;
}

sub board_close {
  close $BOARD;
}

sub board_close_if_open {
  if (($BOARD) && ($BOARD->opened)) {
    board_close;
  }
}

# PROMPT

sub prompt_redraw {
  my ($maxy, $maxx);
  $PROMPT{win}->getmaxyx($maxy, $maxx);
  $PROMPT{win}->move($maxy-1, 0);
  $PROMPT{win}->clrtoeol;

  my $max_val_len = $maxx - length($PROMPT{prompt})-1;
  $text = $PROMPT{prompt}." ".(substr $PROMPT{value}, -$max_val_len);
  $PROMPT{win}->addstring($maxy-1, 0, $text);
}

sub prompt_keypress {
  my ($c, $key) = @_;
  if ($c =~ /[\S ]/) {
    $PROMPT{value} .= $c;
    prompt_redraw;
  } elsif (($key == KEY_BACKSPACE) && ($PROMPT{value})) {
    $PROMPT{value} = substr $PROMPT{value}, 0, -1;
    prompt_redraw;
  }
}

sub prompt_show {
  my ($win, $prompt, $default) = @_;

  %PROMPT = ( win => $win, prompt => $prompt, value => $default );
  prompt_redraw;

  curs_set(1);
  my ($c, $key);
  while (!($c eq "\n")) {
    ($c, $key) = $win->getchar;
    prompt_keypress $c, $key;
  }
  curs_set(0);
  return $PROMPT{value};
}

# GAME VIEW

sub game_new_node {
  my ($move, $parent) = @_;
  my $node = {
    pos => undef,
    move => $move,
    mn => 0,
    prev => undef,
    next => undef,
    NAG => [],
    variants => [],
    comments => [],
  };
  if (defined($parent)) {
    $node->{prev} = $parent;
    $node->{pos} = new Chess::Rep($parent->{pos}->get_fen);
    $node->{pos}->go_move($move);
    $node->{mn} = $parent->{mn}+1;
  } else {
    $node->{pos} = new Chess::Rep;
    if (defined($move)) {
      $node->{pos}->go_move($move);
    }
  }
  return $node;
}

sub game_parse {
  my ($text, $parent) = @_;

  my $game = new Chess::PGN::Parse undef, $text;
  $game->read_game;
  $game->parse_game({save_comments => 'yes', comments_struct => 'hol'});
  my $moves = $game->moves;
  my $comments = $game->comments;

  my $root;
  if (!defined($parent)) {
    $root = game_new_node (undef, undef);
  } else {
    my $nextmove = shift @$moves;
    $root = game_new_node($nextmove, $parent);
  }

  my ($node, $prevnode) = ($root, undef);
  for (@$moves) {
    $prevnode = $node;
    $node = game_new_node $_, $prevnode;
    push @{$prevnode->{variants}}, $node;
    $prevnode->{next} = $node;
    my $hmn = int($node->{mn}/2+0.5) . ($node->{mn} % 2 == 1 ? "w" : "b");
    if (defined($comments->{$hmn}->{NAG})) {
      $node->{NAG} = $comments->{$hmn}->{NAG};
    }
    if (defined($comments->{$hmn}->{RAV})) {
      for (@{$comments->{$hmn}->{RAV}}) {
        s/^\(//; s/\)$//;
        my $childnode = game_parse($_, $node->{prev});
        push @{$node->{prev}->{variants}}, $childnode;
      }
    }
    if (defined($comments->{$hmn}->{brace})) {
      for (@{$comments->{$hmn}->{brace}}) {
        s/^\{\s*//; s/\s*\}$//g;
        push @{$node->{comments}}, $_;
      }
    }
  }
  return $root;
}

sub game_tree_to_movelist {
  my $node = $GAME{movetree};
  my $result = [];
  while (@{$node->{variants}}) {
    $node = $node->{variants}->[0];
    push @{$result}, $node->{move};
  }
  return $result;
}

sub game_tree_to_str {
  my $node = shift;
  if (!defined($node->{prev})) {
    $node = $node->{variants}->[0];
  }

  my @result = ();
  my $clen = 0;
  while (defined($node)) {
    # TODO move number
    if (($node->{mn} % 2 == 1) || ($#{$node->{prev}->{comments}} > 0)
        || ($#{$node->{prev}->{variants}} > 0)) {
      push @result, move_number($node->{mn});
    }
    push @result, $node->{move};
    for (@{$node->{comments}}) {
      if ($_) { push @result, "{$_}"; }
    }
    if ($node == $node->{prev}->{variants}->[0]) {
      for (my $i = 1; $i <= $#{$node->{prev}->{variants}}; $i++) {
        push @result, "(" . game_tree_to_str($node->{prev}->{variants}->[$i]) . ")";
      }
    }
    last if ($#{$node->{variants}} < 0);
    $node = $node->{variants}->[0];
  }
  return join(" ", @result);
}

sub game_save {
  my $game = $GAMES->[$GAME{idx}];
  #print STDERR game_tree_to_str($GAME{movetree});   # DEBUG
  $game->{GameMoves} = game_tree_to_movelist;
  $game->{Game} = game_tree_to_str $GAME{movetree};
}

sub game_reset_variant {
  my $node = shift;
  if (!defined($node)) {
    $node = $GAME{curmove};
  }
  # reset to the mainline from the current move onwards
  my $j = $#{$GAME{variant}};
  while (($j > -1) && ($GAME{variant}->[$j]->{mn} > $node->{mn})) {
    $GAME{variant}->[$j]->{prev}->{next} =
      $GAME{variant}->[$j]->{prev}->{variants}->[0];
    $j--;
  }
  splice @{$GAME{variant}}, ($j+1);
}

sub game_draw_header {
  my ($x1, $y1, $x2, $y2) = @_;
  my $win = $GAME{win};
  my @lines = ();

  my $game = $GAMES->[$GAME{idx}];
  my $white = $game->{White} .
              ($game->{WhiteTitle} ? " $game->{WhiteTitle}" : "") .
              ($game->{WhiteElo} ? " ($game->{WhiteElo})" : "");
  my $black = $game->{Black} .
              ($game->{BlackTitle} ? " $game->{BlackTitle}" : "") .
              ($game->{BlackElo} ? " ($game->{BlackElo})" : "");
  push @lines, "$white — $black";
  push @lines, "$game->{Event}" .
               ($game->{Round} ? " round $game->{Round}" : "");
  push @lines, "$game->{Site} $game->{Date}";
  push @lines, "$game->{ECO} $game->{Opening}";

  my $center = int(($x2-$x1)/2);
  $win->attron(A_BOLD);
  for (my $j = 0; $j <= $#lines; $j++) {
    $win->addstring($j, int($center-length($lines[$j])/2), $lines[$j]);
  }
  $win->attroff(A_BOLD);
}

sub game_draw_moves_list {
  my ($x1, $y1, $x2, $y2) = @_;

  my $win = $GAME{win};
  my ($cx, $cy) = ($x1, $y1);

  my $n = $GAME{movetree};
  do {
    $n = $n->{next};
    #if ($n->{mn} <= 0) { $n = $n->{next}; next; }
    my $mn = int(($n->{mn}+1)/2).".";
    if ($n->{mn} % 2 == 1) {
       my $nextlength = length("$mn $n->{move} "
                               . (defined($n->{next}) ? $n->{next}->{move} : ""));
      if ($cx + $nextlength > $x2) {
        $cx = $x1;
        $cy++;
        last if $cy > $y2;
      }
      $win->addstring($cy, $cx, "$mn");
      $cx += length($mn) + 1;
    } 
    if (($n == $GAME{curmove}) && !defined($GAME{append})) {
      $win->attron(A_REVERSE);
    }
    $win->addstring($cy, $cx, $n->{move});
    $cx += length($n->{move}) + 1;
    if (($n == $GAME{curmove}) && !defined($GAME{append})) {
      $win->attroff(A_REVERSE);
    }
  } while (defined($n->{next}));
  # append mode cursor
  # TODO going to the next line if the text exceeds the line width
  if (defined($GAME{append})) {
    my $appendstr = $GAME{append} ? $GAME{append} : " ";
    if ($n->{mn} % 2 == 0) {
      $appendstr = int($n->{mn}/2+1). ". " . $appendstr;
    }
    $win->attron(A_REVERSE);
    $win->addstring($cy, $cx, $appendstr);
    $win->attroff(A_REVERSE);
    $cx += length($appendstr)+1;
  }
  # append the result to the moves list
  # TODO only if in main line!
  if ((defined($GAMES->[$GAME{idx}]->{Result})) && (!@{$GAME{variant}})) {
    my $result = $GAMES->[$GAME{idx}]->{Result};
    if ($cx + length($result) > $x2) { $cx = $x1; $cy++; }
    $win->addstring($cy, $cx, $result);
  }
  return $cy;
}

sub game_draw_variants {
  my ($x1, $y1, $x2, $y2) = @_;

  my ($cx, $cy) = ($x1, $y1);
  if ((defined($GAME{curmove}->{prev}))
      && ($GAME{curmove}->{prev}->{next} == $GAME{curmove}->{prev}->{variants}->[0])) {
    my $i = 1;
    for (my $i = 1; $i <= $#{$GAME{curmove}->{prev}->{variants}}; $i++) {
      my $node = $GAME{curmove}->{prev}->{variants}->[$i];
      my $text = "[".$i."]$node->{move}";
      $GAME{win}->addstring($cy, $cx, $text);
      $cx += length($text)+1;
      if ($cx > $x2) {
        $cx = $x1;
        $cy++;
      }
    }
  }
  return $cy;
}

sub game_draw_comments {
  my ($x1, $y1, $x2, $y2) = @_;

  my $j = 0;
  for (@{$GAME{curmove}->{comments}}) {
    $GAME{win}->addstring($y1+$j++, $x1, $_);
  }
  return $y1+$j;
}

sub game_redraw {
  my ($maxy, $maxx);
  $GAME{win}->getmaxyx($maxy, $maxx);

  $GAME{win}->clear;

  game_draw_header 0, 0, $maxx, 5;
  my $y = game_draw_moves_list 0, 5, $maxx, 15;
  $y = game_draw_variants 0, ($y+2), $maxx, ($y+8);
  $y = game_draw_comments 0, ($y+2), $maxx, ($y+8);

  # add status bar
  my $status = join "; ",
    (map { move_number($_->{mn}) . " " . $_->{move} } @{$GAME{variant}});
  if ($status) {
    $GAME{win}->attron(A_REVERSE);
    $GAME{win}->addstring($maxy-1, 0, $status);
    $GAME{win}->attroff(A_REVERSE);
  }

  # print the position to the board
  if (($BOARD) && ($BOARD->opened)) {
    print $BOARD $GAME{curmove}->{pos}->get_fen."\n";
  }
}

sub game_appendmode_keypress {
  my ($c, $key) = @_;

  if ($key == KEY_BACKSPACE) {
    $GAME{append} = substr $GAME{append}, 0, (length($GAME{append})-1);
    game_redraw;
  } elsif ($c eq "\n") {
    # exit the append mode
    undef $GAME{append};
    # if nothing was added and nothing deleted, discard the change and restore
    # the previously viewed line
    my $change = $GAME{changes}->[-1];
    if (!defined($change->{addnode}) && !defined($change->{delnode})) {
      $GAME{curmove}->{next} = $change->{next};
      pop @{$GAME{changes}};
    }
    # if a variant was deleted, restore the main line
    elsif ((!defined($change->{addnode})) && ($change->{var} > 0)) {
      $GAME{curmove}->{next} = $GAME{curmove}->{variants}->[0];
      game_reset_variant;
    }
    game_redraw;
  } elsif ($c =~ /[qweruiopasdfjkl;zxcvm,.\/=ntT]/) {
    $c =~ tr/qweruiopasdfjkl;zxcvm,.\/=ntT/12345678abcdefghRNBQKBNR=x+#/;
    $GAME{append} .= $c;
    game_redraw;
  } elsif ($c eq 'y') {
    $GAME{append} .= "O-O";
    game_redraw;
  } elsif ($c eq 'Y') {
    $GAME{append} .= "O-O-O";
    game_redraw;
  } elsif ($c eq ' ') {
    # try adding the currently appended move
    # TODO refactor into a subroutine
    try {
      my $node = game_new_node($GAME{append}, $GAME{curmove});
      my $change = $GAME{changes}->[-1];
      if (!defined($change->{addnode}) && defined($change->{var})) {
        # if the added move is not on the main line (this may only happen with
        # the first added move)
        splice @{$GAME{curmove}->{variants}}, $change->{var}, 0, $node;
      } else {
        # main line
        push @{$GAME{curmove}->{variants}}, $node;
      }
      # if we've inserted a new variant, push it to the current variant stack
      if ($node != $GAME{curmove}->{variants}->[0]) {
        push @{$GAME{variant}}, $node;
      }
      $GAME{curmove}->{next} = $node;
      $GAME{append} = "";
      $GAME{curmove} = $node;
      # if this is the first appended node -> set $change->{addnode} and
      # clear the variant stack from this move onwards
      if (!defined($GAME{changes}->[-1]->{addnode})) {
        $GAME{changes}->[-1]->{addnode} = $node;
        game_reset_variant;
      }
    };
    game_redraw;
  }
}

sub game_keypress {
  my ($c, $key) = @_;

  my $last_move_idx = $#{$GAMES->[$GAME{idx}]->{GameMoves}}+1;

  if (defined $GAME{append}) {
    game_appendmode_keypress $c, $key;
  } elsif ($key == KEY_RESIZE) {
    game_redraw;
  } elsif ($c eq 'g') {
    $GAME{curmove} = $GAME{movetree};
    game_redraw;
  } elsif ($c eq 'G') {
    while (defined($GAME{curmove}->{next})) {
      $GAME{curmove} = $GAME{curmove}->{next};
    }
    game_redraw;
  } elsif (($c eq 'j') && (defined($GAME{curmove}->{next}))) {
    $GAME{curmove} = $GAME{curmove}->{next};
    game_redraw;
  } elsif (($c eq 'k') && (defined($GAME{curmove}->{prev}))) {
    $GAME{curmove} = $GAME{curmove}->{prev};
    game_redraw;
  } elsif ($c eq 'a') {
    # enter the append mode
    while (defined($GAME{curmove}->{next})) {
      $GAME{curmove} = $GAME{curmove}->{next};
    }
    $GAME{append} = "";
    push @{$GAME{changes}},
         { at => $GAME{curmove}, var => undef, next => undef,
           addnode => undef, delnode => undef };
    game_redraw;
  } elsif ($c eq 'A') {
    # delete everything behind the cursor and enter the append mode
    my $idx = 0;
    # FIXME avoid an infinite loop, check whether
    # idx <= $#{GAME{curmove}->{variants}}
    while ($GAME{curmove}->{next} != $GAME{curmove}->{variants}->[$idx]) {
      $idx++;
      #last if (++$idx > $#{$GAME{curmove}->{variants}});
    }
    push @{$GAME{changes}},
         { at => $GAME{curmove}, var => $idx, next => $GAME{curmove}->{next},
           addnode => undef, delnode => $GAME{curmove}->{next} };
    $GAME{curmove}->{next} = undef;
    splice @{$GAME{curmove}->{variants}}, $idx, 1;
    $GAME{append} = "";
    game_redraw;
  } elsif ($c eq 'i') {
    $GAME{curmove} = $GAME{curmove}->{prev};
    $GAME{append} = "";
    push @{$GAME{changes}},
         { at => $GAME{curmove}, var => undef, next => $GAME{curmove}->{next},
           addnode => undef, delnode => undef };
    $GAME{curmove}->{next} = undef;
    game_reset_variant;
    game_redraw;
  } elsif ($c eq 'u') {
    # undo the last append
    if (@{$GAME{changes}}) {
      my $change = pop @{$GAME{changes}};
      $GAME{curmove} = $change->{at};

      # delete the variant that was added by the change and restore the
      # previously deleted one
      if (!defined($change->{var})) {
        pop @{$GAME{curmove}->{variants}};
        if (defined($change->{delmove})) {
          push @{$GAME{curmove}->{variants}}, $change->{delnode};
        }
      } else {
        my @add = ();
        if (defined($change->{delnode})) {
          push @add, $change->{delnode};
        }
        splice @{$GAME{curmove}->{variants}}, $change->{var}, 1, @add;
      }

      # revert the view
      $GAME{curmove}->{next} = $change->{next};
      game_reset_variant;
      game_redraw;
    }
  } elsif ($c eq 'b') {
    if (($BOARD) && ($BOARD->opened)) {
      board_close;
    } else {
      board_open;
      game_redraw;
    }
  } elsif ($c eq 'y') {
    yank $GAME{curmove}->{pos}->get_fen;
  } elsif ($c eq 's') {
    game_save;
    my $file = prompt_show $GAME{win}, "save to file:", $FILENAME;
    save $file;
  } elsif ($c eq 'c') {
    if (!@{$GAME{curmove}->{comments}}) {
      push @{$GAME{curmove}->{comments}}, "";
    }
    $GAME{curmove}->{comments}->[0] =
      prompt_show $GAME{win}, "quick comment:",
                  $GAME{curmove}->{comments}->[0];
    game_redraw;
  } elsif ($c eq 'C') {
    if (defined($ENV{EDITOR})) {
      my ($fh, $filename) = tempfile(UNLINK => 1);
      for (@{$GAME{curmove}->{comments}}) {
        print $fh $_."\n\n";
      }
      close $fh;
      system $ENV{EDITOR}, $filename;
      open $fh, "<", $filename;
      $GAME{curmove}->{comments} = [""];
      for (<$fh>) {
        s/\s*$//;
        if (!$_) {
          push @{$GAME{curmove}->{comments}}, "";
        } else {
          # add a space if it's not the first line of the comment
          if ($GAME{curmove}->{comments}->[$#{$GAME{curmove}->{comments}}]) {
            $_ .= ' ';
          }
          $GAME{curmove}->{comments}->[$#{$GAME{curmove}->{comments}}] .= $_;
        }
      }
      # remove the last element if it's empty
      if (!$GAME{curmove}->{comments}->[$#{$GAME{curmove}->{comments}}]) {
        splice @{$GAME{curmove}->{comments}}, -1;
      }
      close $fh;
      endwin;
      setup_curses $GAME{win};
      game_redraw;
    }
  } elsif ($c eq 'E') {
    if (defined($ENV{EDITOR})) {
      game_save;
      my ($fh, $filename) = tempfile(UNLINK => 1);
      print_game $fh, $GAMES->[$GAME{idx}];
      close $fh;
      system $ENV{EDITOR}, $filename;
      open $fh, "<", $filename;
      my $gametext = "";
      while (<$fh>) { $gametext .= $_; }
      # read the result and substitite the current game for it
      my $game = new Chess::PGN::Parse undef, $gametext;
      $game->read_game;
      $GAMES->[$GAME{idx}] = $game->tags;
      $GAME{movetree} = game_parse($GAMES->[$GAME{idx}]->{Game}, undef);
      $GAME{curmove} = $GAME{movetree};
      endwin;
      setup_curses $GAME{win};
      game_redraw;
    }
  } elsif ($c eq '0') {
    my $node = pop @{$GAME{variant}};
    if (defined($node)) {
      $node->{prev}->{next} = $node->{prev}->{variants}->[0];
      $GAME{curmove} = $node->{prev}->{variants}->[0];
      game_redraw;
    }
  } elsif ($c =~ /[1-9]/) {
    my $i = int($c);
    my $prev = $GAME{curmove}->{prev};
    # TODO also check whether we're on the main line here
    if ($i <= $#{$prev->{variants}}) {
      game_reset_variant $prev;
      $prev->{next} = $prev->{variants}->[$i];
      $GAME{curmove} = $prev->{next};
      push @{$GAME{variant}}, $GAME{curmove};
      game_redraw;
    }
  }
}

sub game_show {
  my $win = shift;
  my $idx = shift;
  my $move_idx = shift;

  if (!defined($move_idx)) { $move = 0; }
  %GAME = (
    win => $win, idx => $idx, curmove => undef, board => 0,
    append => undef, changes => [], comments => undef, variant => [] );
  $GAME{movetree} = game_parse($GAMES->[$idx]->{Game}, undef);
  $GAME{curmove} = $GAME{movetree};
  for (my $i = 0; $i < $move_idx; $i++) {
    $GAME{curmove} = $GAME{curmove}->{next};
  }
  game_redraw;

  my ($c, $key);
  while (!($c eq 'q') || (defined $GAME{append})) {
    ($c, $key) = $win->getchar();
    game_keypress $c, $key;
  }
  game_save;
}

# TREE VIEW

sub tree_make_children {
  my $node = shift;

  my %illegal = ();

  # create the child nodes
  $node->{children} = {};
  my $pos = new Chess::Rep;
  for my $idx (@{$node->{games}}) {
    my $move = $GAMES->[$idx]->{GameMoves}->[$node->{depth}];
    if ((!defined($node->{children}->{$move}))
       && (!defined($illegal{$move}))) {
      try {
        $pos->set_from_fen($node->{pos});
        $pos->go_move($move);
        $node->{children}->{$move} = {
          expanded => 0, depth => $node->{depth}+1, games => [],
          children => undef, text => undef, pos => $pos->get_fen
        }
      } catch {
        $illegal{$move} = 1;
      }
    }
    if (defined($node->{children}->{$move})) {
      push @{$node->{children}->{$move}->{games}}, $idx;
    }
  }
  # add the text descriptions of the nodes (like e.g. "+ 1. ..e6 (10)")
  for my $key (keys %{$node->{children}}) {
    $n = $#{$node->{children}->{$key}->{games}}+1;
    my $child = $node->{children}->{$key};
    my $mn = int(($child->{depth}+1)/2);
    my $mt = "$mn. ".($child->{depth} % 2 == 0 ? ".." : "") . $key;
    if ($n > 1) {
      $child->{text} = "+ $mt ($n)";
    } else {
      my $game = $GAMES->[$child->{games}->[0]];
      $child->{text} = "* $mt: " . format_game $game;
    }
  }
}

sub tree_create {
  my $root = {
    expanded => 1, depth => 0, games => [], children => undef,
    pos => "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1",
  };
  for ($i = 0; $i <= $#$GAMES; $i++) {
    push @{$root->{games}}, $i;
  }
  tree_make_children $root;
  $TREE{root} = $root;

  $TREE{list} = [];
  for my $key (sort { $#{$root->{children}->{$b}->{games}}
                      <=> $#{$root->{children}->{$a}->{games}}
                    } keys %{$root->{children}}) {
    push @{$TREE{list}}, $root->{children}->{$key};
  }
}

sub tree_get_visible_subtree {
  my $node = shift;
  my @result = ($node);
  if ($node->{expanded}) {
    for my $key (sort { $#{$node->{children}->{$b}->{games}}
                        <=> $#{$node->{children}->{$a}->{games}}
                      } keys %{$node->{children}}) {
      my $child = $node->{children}->{$key};
      splice @result, @result, 0, tree_get_visible_subtree($child);
    }
  }
  return @result;
}

# TODO do not expand leaf nodes!
sub tree_expand_node {
  my $i = shift;
  my $node = $TREE{list}->[$i];

  $node->{expanded} = 1;
  if (!defined($node->{children})) {
    tree_make_children $node;
  }
  my @vn = tree_get_visible_subtree $node;
  splice @{$TREE{list}}, $i, 1, @vn;
}

sub tree_collapse_node {
  my $i = shift;
  my $node = $TREE{list}->[$i];

  $node->{expanded} = 0;
  if ($i == $#{$TREE{list}}) { return }
  for ($j = $i+1;
       ($j < $#{$TREE{list}}) && ($TREE{list}->[$j]->{depth} > $node->{depth});
       $j++) {}
  splice @{$TREE{list}}, ($i+1), ($j-$i-1);
}

sub tree_correct_top {
  my ($maxy, $maxx);
  $TREE{win}->getmaxyx($maxy, $maxx);

  if ($TREE{sel} < $TREE{top}) {
    $TREE{top} = $TREE{sel};
  } elsif ($TREE{sel} >= $TREE{top}+$maxy) {
    $TREE{top} = $TREE{sel}-$maxy+1;
  }
}

sub tree_redraw {
  my $win = $TREE{win};
  my $i = 0;

  my ($maxy, $maxx);
  $win->getmaxyx($maxy, $maxx);

  $win->clear;
  for (my $i = 0; $i < $maxy; $i++) {
    my $node = $TREE{list}->[$TREE{top}+$i];
    my $shift = ($node->{depth}-1)*2;
    if ($TREE{top}+$i == $TREE{sel}) { $win->attron(A_REVERSE); }
    if ($shift + length($node->{text}) <= $maxx) {
      $win->addstring($i, $shift, $node->{text});
    } else {
      $win->addstring(
        $i, $shift, substr($node->{text}, 0, ($maxx-$shift-1)) . "+");
    }
    if ($TREE{top}+$i == $TREE{sel}) { $win->attroff(A_REVERSE); }
    last if ($TREE{top}+$i >= $#{$TREE{list}});
  }
  if (($BOARD) && ($BOARD->opened)) {
    print $BOARD $TREE{list}->[$TREE{sel}]->{pos}."\n";
  }
}

sub tree_keypress {
  my ($c, $key) = @_;
  if ($key == KEY_RESIZE) {
    tree_redraw;
  } elsif ($c eq 'g') {
    $TREE{sel} = 0;
    $TREE{top} = 0;
    tree_redraw;
  } elsif ($c eq 'G') {
    $TREE{sel} = $#{$TREE{list}};
    tree_correct_top;
    tree_redraw;
  } elsif (($c eq 'k') && ($TREE{sel} > 0)) {
    $TREE{sel}--;
    tree_correct_top;
    tree_redraw;
  } elsif (($c eq 'j') && ($TREE{sel} < $#{$TREE{list}})) {
    $TREE{sel}++;
    tree_correct_top;
    tree_redraw;
  } elsif ($c eq 'h') {
    my $node = $TREE{list}->[$TREE{sel}];
    if (($#{$node->{games}} > 0) && ($node->{expanded})) {
      tree_collapse_node $TREE{sel};
      tree_redraw;
    }
  } elsif ($c eq 'l') {
    my $node = $TREE{list}->[$TREE{sel}];
    if (($#{$node->{games}} > 0) && (!$node->{expanded})) {
      tree_expand_node $TREE{sel};
      tree_redraw;
    }
  } elsif ($c eq 'b') {
    if (($BOARD) && ($BOARD->opened)) {
      board_close;
    } else {
      board_open;
      tree_redraw;
    }
  } elsif ($c eq 'y') {
    yank $TREE{list}->[$TREE{sel}]->{pos};
  } elsif ($c eq "\n" || $c eq " ") {
    if ($#{$TREE{list}->[$TREE{sel}]->{games}} == 0) {
      my $game_idx = $TREE{list}->[$TREE{sel}]->{games}->[0];
      my $move = $TREE{list}->[$TREE{sel}]->{depth};
      game_show $TREE{win}, $game_idx, $move;
    } elsif ($TREE{list}->[$TREE{sel}]->{expanded}) {
      tree_collapse_node $TREE{sel};
    } else {
      tree_expand_node $TREE{sel};
    }
    tree_redraw;
  }
}

sub tree_show {
  my $win = shift;

  $TREE{win} = $win;
  if (!defined($TREE{root})) {
    tree_create;
  }
  tree_redraw;

  my ($c, $key);
  while (!($c eq 'q')) {
    ($c, $key) = $win->getchar();
    tree_keypress $c, $key;
  }
}

# LIST VIEW

sub list_correct_top {
  my $win = $LIST{win};

  my ($maxy, $maxx);
  $win->getmaxyx($maxy, $maxx);

  if ($LIST{sel} < $LIST{top}) {
    $LIST{top} = $LIST{sel};
  } elsif ($LIST{sel}-$LIST{top} >= $maxy) {
    $LIST{top} = $LIST{sel}-$maxy+1;
  }
}

sub list_redraw {
  my $win = $LIST{win};

  my ($maxy, $maxx);
  $win->getmaxyx($maxy, $maxx);

  $win->clear;
  $bottom = ($LIST{top}+$maxy < $#$GAMES ? $LIST{top}+$maxy : $#$GAMES);
  my $lines = format_list($LIST{top}, $bottom);
  for ($i = 0; $i <= $#$lines; $i++) {
    if ($LIST{top}+$i == $LIST{sel}) { $win->attron(A_REVERSE); }
    $win->addstring($i, 0, $lines->[$i]);
    if ($LIST{top}+$i == $LIST{sel}) { $win->attroff(A_REVERSE); }
  }
}

sub list_keypress {
  my ($c, $key) = @_;
  if ($key == KEY_RESIZE) {
    list_redraw;
  } elsif ($c eq 'g') {
    $LIST{sel} = 0;
    $LIST{top} = 0;
    list_redraw;
  } elsif ($c eq 'G') {
    $LIST{sel} = $#$GAMES;
    list_correct_top;
    list_redraw;
  } elsif (($c eq 'k') && ($LIST{sel} > 0)) {
    $LIST{sel}--;
    list_correct_top;
    list_redraw;
  } elsif (($c eq 'j') && ($LIST{sel} < $#$GAMES)) {
    $LIST{sel}++;
    list_correct_top;
    list_redraw;
  } elsif ($c eq "t") {
    tree_show $LIST{win};
    board_close_if_open;
    list_redraw;
  } elsif ($c eq "\n") {
    game_show $LIST{win}, $LIST{sel};
    board_close_if_open;
    list_redraw;
  }
}

sub list_show {
  my $win = shift;

  $LIST{win} = $win;
  list_redraw;

  my ($c, $key);
  while (!($c eq 'q')) {
    ($c, $key) = $win->getchar();
    list_keypress $c, $key;
  }
}


# MAIN BODY

my $win = new Curses;

setup_curses $win;
list_show $win;

curs_set(1);
endwin;

