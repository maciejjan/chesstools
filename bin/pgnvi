#!/usr/bin/perl

use Curses;
use Try::Tiny;
use utf8;

use Chess::Rep;
use Chess::PGN::Parse;

our %GAME;
our $BOARD;

our %LIST = (
  sel => 0,
  top => 0,
);

our %TREE = (
  sel => 0,
  root => undef,
  list => undef,
);

our @LIST_FIELDS = ("No", "White", "Black", "Year", "Result", "ECO");

our $BOARDCMD = "drawboard";
our $YANKCMD = "xclip -i";

if (($#ARGV < 0) || ($ARGV[0] eq "-h") || ($ARGV[0] eq "--help")) {
  die "usage: pgnvi PGN_FILE";
}

our $FILENAME = $ARGV[0];

$pgn = new Chess::PGN::Parse "$FILENAME"
  || die "Could not open file: $FILENAME";
$GAMES = $pgn->smart_read_all({save_comments => 'yes', comments_struct => 'array'});

# TODO (for v 0.1)
# - improvements in the tree view:
#   - compress nodes with only one child
# - list & tree view
#   - searching
#   - filtering
# - scrolling of the move list
# - variants
# - wrapping comments
# - editing comments with $EDITOR
# TODO metadata editing mode
# FIXME bugs:
# - if a board window is closed, pgnvi still tries to write to the pipe and
#   crashes

sub yank {
  my $arg = shift;
  if (open(my $pipe, "|-:encoding(UTF-8)", $YANKCMD)) {
    print $pipe $arg;
    close($pipe);
  }
}

sub number_moves {
  my $mn = 0;
  my @result = ();
  while (my $move = shift @_) {
    if ($mn % 2 == 0) {
      push @result, int($mn/2+1).".";
    }
    push @result, $move;
    $mn++;
  }
  return @result;
}

sub print_game {
  my $fh = shift;
  my $game = shift;
  for my $key (keys %$game) {
    if (($key =~ /^[A-Z].*/) && ($key !~ /Game.*/)) {
      print $fh "[$key \"$game->{$key}\"]\n";
    }
  }
  print $fh "\n";
  print $fh (join " ", number_moves(@{$game->{GameMoves}}))."\n\n";
}

sub save {
  my $filename = shift;
  open $fh, "+>", $filename;
  for my $game (@$GAMES) {
    print_game $fh, $game;
  }
  close $fh;
}

sub format_game {
  my $game = shift;
  my $year = substr $game->{Date}, 0, 4;
  return $game->{White}." — ".$game->{Black}." ($year) — ".$game->{Result};
}

sub get_field_for_game {
  my ($field, $idx) = @_;
  if ($field eq "Year") {
    return substr $GAMES->[$idx]->{Date}, 0, 4;
  } elsif ($field eq "No") {
    return $idx+1;
  } elsif ($field eq "keys") { # for debug purposes only
    return join(",",(keys %{$GAMES->[$idx]}));
  } elsif ($field eq "moves") { # for debug purposes only
    return join(",",@{$GAMES->[$idx]->{GameMoves}});
  } else {
    return $GAMES->[$idx]->{$field};
  }
}

sub format_list {
  my ($start, $end) = @_;

  $result = [];
  $fieldlen = ();
  for my $field (@LIST_FIELDS) {
    for (my $i = $start; $i <= $end; $i++) {
      my $l = length(get_field_for_game($field, $i));
      if ((!defined($fieldlen{$field})) || ($fieldlen{$field} < $l)) {
        $fieldlen{$field} = $l;
      }
    }
  }
  for (my $i = $start; $i <= $end; $i++) {
    my @str = ();
    for my $field (@LIST_FIELDS) {
      my $val = get_field_for_game($field, $i);
      push @str, $val;
      for (my $j = 0; $j < ($fieldlen{$field} - length $val)+2; $j++) {
        push @str, " ";
      }
    }
    push @$result, (join "", @str);
  }
  return $result;
}

# BOARD

sub board_open {
  open $BOARD, "|-", $BOARDCMD;
  autoflush $BOARD 1;
}

sub board_close {
  close $BOARD;
}

sub board_close_if_open {
  if (($BOARD) && ($BOARD->opened)) {
    board_close;
  }
}

# GAME VIEW

sub game_precompute_positions {
  my $moves = $GAMES->[$GAME{idx}]->{GameMoves};
  $GAME{pos} = new Chess::Rep;
  $GAME{positions} = [$GAME{pos}->get_fen];
  for (my $i = 0; $i <= $#$moves; $i++) {
    $GAME{pos}->go_move($moves->[$i]);
    push @{$GAME{positions}}, $GAME{pos}->get_fen;
  }
}

sub game_draw_header {
  my ($x1, $y1, $x2, $y2) = @_;
  my $win = $GAME{win};
  my @lines = ();

  my $game = $GAMES->[$GAME{idx}];
  my $white = $game->{White} .
              ($game->{WhiteTitle} ? " $game->{WhiteTitle}" : "") .
              ($game->{WhiteElo} ? " ($game->{WhiteElo})" : "");
  my $black = $game->{Black} .
              ($game->{BlackTitle} ? " $game->{BlackTitle}" : "") .
              ($game->{BlackElo} ? " ($game->{BlackElo})" : "");
  push @lines, "$white — $black";
  push @lines, "$game->{Event}" .
               ($game->{Round} ? " round $game->{Round}" : "");
  push @lines, "$game->{Site} $game->{Date}";
  push @lines, "$game->{ECO} $game->{Opening}";

  my $center = int(($x2-$x1)/2);
  $win->attron(A_BOLD);
  for (my $j = 0; $j <= $#lines; $j++) {
    $win->addstring($j, int($center-length($lines[$j])/2), $lines[$j]);
  }
  $win->attroff(A_BOLD);
}

sub game_draw_moves_list {
  my ($x1, $y1, $x2, $y2) = @_;

  my $moves = $GAMES->[$GAME{idx}]->{GameMoves};
  my $win = $GAME{win};
  my ($cx, $cy) = ($x1, $y1);

  my $last_move_idx = $#{$GAMES->[$GAME{idx}]->{GameMoves}}+1;

  for (my $i = 0; $i <= $#$moves; $i++) {
    my $mn = int($i/2+1).".";
    if ($i % 2 == 0) {
      if ($cx + length("$mn $moves->[$i] $moves->[$i+1]") > $x2) {
        $cx = $x1;
        $cy++;
        last if $cy > $y2;
      }
      $win->addstring($cy, $cx, "$mn");
      $cx += length($mn) + 1;
    } 
    if (($i+1 == $GAME{move}) && !defined($GAME{append})) {
      $win->attron(A_REVERSE);
    }
    $win->addstring($cy, $cx, $moves->[$i]);
    $cx += length($moves->[$i]) + 1;
    if (($i+1 == $GAME{move}) && !defined($GAME{append})) {
      $win->attroff(A_REVERSE);
    }
  }
  # append mode cursor
  # TODO going to the next line if the text exceeds the line width
  if (defined($GAME{append})) {
    my $appendstr = $GAME{append} ? $GAME{append} : " ";
    my $nmoves = $#{$GAMES->[$GAME{idx}]->{GameMoves}}+1;
    if ($nmoves % 2 == 0) {
      $appendstr = int($nmoves/2+1). ". " . $appendstr;
    }
    $win->attron(A_REVERSE);
    $win->addstring($cy, $cx, $appendstr);
    $win->attroff(A_REVERSE);
    $cx += length($appendstr)+1;
  }
  # append the result to the moves list
  if (defined($GAMES->[$GAME{idx}]->{Result})) {
    my $result = $GAMES->[$GAME{idx}]->{Result};
    if ($cx + length($result) > $x2) { $cx = $x1; $cy++; }
    $win->addstring($cy, $cx, $result);
  }
}

sub game_draw_comments {
  my ($x1, $y1, $x2, $y2) = @_;

  my $moves = $GAMES->[$GAME{idx}]->{GameMoves};

  my $cm2 = int($GAME{move}/2+0.5) . ($GAME{move} % 2 == 1 ? "w" : "b");
  if (defined($GAME{comments}->{$cm2})) {
    my $j = 0;
    for $c (@{$GAME{comments}->{$cm2}}) {
      $win->addstring($y1+$j, $x1, $c);
      $j++;
    }
  }
}

sub game_redraw {
  my ($maxy, $maxx);
  $GAME{win}->getmaxyx($maxy, $maxx);

  $GAME{win}->clear;

  game_draw_header 0, 0, $maxx, 5;
  game_draw_moves_list 0, 5, $maxx, 15;
  #game_draw_comments 0, 15, $maxx, 20;

  # print the position to the board
  if (($BOARD) && ($BOARD->opened)) {
    print $BOARD $GAME{positions}->[$GAME{move}]."\n";
  }
}

sub game_append_keypress {
  my ($c, $key) = @_;

  if ($key == KEY_BACKSPACE) {
    $GAME{append} = substr $GAME{append}, 0, (length($GAME{append})-1);
    game_redraw;
  } elsif ($c eq "\n") {
    # exit the append mode
    undef $GAME{append};
    game_redraw;
  } elsif ($c =~ /[qweruiopasdfjkl;zxcvm,.\/=ntT]/) {
    $c =~ tr/qweruiopasdfjkl;zxcvm,.\/=ntT/12345678abcdefghRNBQKBNR=x+#/;
    $GAME{append} .= $c;
    game_redraw;
  } elsif ($c eq 'y') {
    $GAME{append} .= "O-O";
    game_redraw;
  } elsif ($c eq 'Y') {
    $GAME{append} .= "O-O-O";
    game_redraw;
  } elsif ($c eq ' ') {
    try {
      $GAME{pos}->set_from_fen($GAME{positions}->[$#{$GAME{positions}}]);
      $GAME{pos}->go_move($GAME{append});
      push @{$GAMES->[$GAME{idx}]->{GameMoves}}, $GAME{append};
      push @{$GAME{positions}}, $GAME{pos}->get_fen;
      push @{$GAME{changes}->[$#{$GAME{changes}}]->{added}}, $GAME{append};
      $GAME{append} = "";
      $GAME{move} = $#{$GAME{positions}};
    };
    game_redraw;
  }
}

sub game_keypress {
  my ($c, $key) = @_;

  my $last_move_idx = $#{$GAMES->[$GAME{idx}]->{GameMoves}}+1;

  if (defined $GAME{append}) {
    game_append_keypress $c, $key;
  } elsif ($key == KEY_RESIZE) {
    game_redraw;
  } elsif ($c eq 'g') {
    $GAME{move} = 0;
    game_redraw;
  } elsif ($c eq 'G') {
    $GAME{move} = $last_move_idx;
    game_redraw;
  } elsif ($c eq 'j') {
    if ($GAME{move} < $last_move_idx) { $GAME{move}++; }
    game_redraw;
  } elsif ($c eq 'k') {
    if ($GAME{move} > 0) { $GAME{move}--; }
    game_redraw;
  } elsif ($c eq 'a') {
    # enter the append mode
    $GAME{append} = "";
    push @{$GAME{changes}}, { added => [], deleted => [] };
    game_redraw;
  } elsif ($c eq 'A') {
    # delete everything behind the cursor and enter the append mode
    my @del = splice @{$GAMES->[$GAME{idx}]->{GameMoves}}, $GAME{move};
    splice @{$GAME{positions}}, ($GAME{move}+1);
    push @{$GAME{changes}}, { added => [], deleted => \@del };
    $GAME{append} = "";
    game_redraw;
  } elsif ($c eq 'u') {
    # undo the last append
    if (length @{$GAME{changes}} > 0) {
      my $change = pop @{$GAME{changes}};
      my $len = $#{$change->{added}}+1;
      my $offset = ($#{$GAMES->[$GAME{idx}]->{GameMoves}}+1) - $len;
      splice @{$GAMES->[$GAME{idx}]->{GameMoves}}, $offset, $len,
        @{$change->{deleted}};
      splice @{$GAME{positions}}, ($offset+1);
      $GAME{pos}->set_from_fen($GAME{positions}->[$offset]);
      for (my $i = $offset; $i <= $#{$GAMES->[$GAME{idx}]->{GameMoves}}; $i++) {
        $GAME{pos}->go_move($GAMES->[$GAME{idx}]->{GameMoves}->[$i]);
        push @{$GAME{positions}}, $GAME{pos}->get_fen;
      }
      $GAME{move} = $offset;
      game_redraw;
    }
  } elsif ($c eq 'b') {
    if (($BOARD) && ($BOARD->opened)) {
      board_close;
    } else {
      board_open;
      game_redraw;
    }
  } elsif ($c eq 'y') {
    yank $GAME{positions}->[$GAME{move}];
  } elsif ($c eq 's') {
    save $FILENAME;
  }
}

sub game_show {
  my $win = shift;
  my $idx = shift;
  my $move = shift;

  if (!defined($move)) { $move = 0; }
  %GAME = (
    win => $win, idx => $idx, move => $move, board => 0,
    append => undef, changes => []);
  game_precompute_positions;
  game_redraw;

  my ($c, $key);
  while (!($c eq 'q') || (defined $GAME{append})) {
    ($c, $key) = $win->getchar();
    game_keypress $c, $key;
  }
}

# TREE VIEW

sub tree_make_children {
  my $node = shift;

  my %illegal = ();

  # create the child nodes
  $node->{children} = {};
  my $pos = new Chess::Rep;
  for my $idx (@{$node->{games}}) {
    my $move = $GAMES->[$idx]->{GameMoves}->[$node->{depth}];
    if ((!defined($node->{children}->{$move}))
       && (!defined($illegal{$move}))) {
      try {
        $pos->set_from_fen($node->{pos});
        $pos->go_move($move);
        $node->{children}->{$move} = {
          expanded => 0, depth => $node->{depth}+1, games => [],
          children => undef, text => undef, pos => $pos->get_fen
        }
      } catch {
        $illegal{$move} = 1;
      }
    }
    if (defined($node->{children}->{$move})) {
      push @{$node->{children}->{$move}->{games}}, $idx;
    }
  }
  # add the text descriptions of the nodes (like e.g. "+ 1. ..e6 (10)")
  for my $key (keys %{$node->{children}}) {
    $n = $#{$node->{children}->{$key}->{games}}+1;
    my $child = $node->{children}->{$key};
    my $mn = int(($child->{depth}+1)/2);
    my $mt = "$mn. ".($child->{depth} % 2 == 0 ? ".." : "") . $key;
    if ($n > 1) {
      $child->{text} = "+ $mt ($n)";
    } else {
      my $game = $GAMES->[$child->{games}->[0]];
      $child->{text} = "* $mt: " . format_game $game;
    }
  }
}

sub tree_create {
  my $root = {
    expanded => 1, depth => 0, games => [], children => undef,
    pos => "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1",
  };
  for ($i = 0; $i <= $#$GAMES; $i++) {
    push @{$root->{games}}, $i;
  }
  tree_make_children $root;
  $TREE{root} = $root;

  $TREE{list} = [];
  for my $key (sort { $#{$root->{children}->{$b}->{games}}
                      <=> $#{$root->{children}->{$a}->{games}}
                    } keys %{$root->{children}}) {
    push @{$TREE{list}}, $root->{children}->{$key};
  }
}

sub tree_get_visible_subtree {
  my $node = shift;
  my @result = ($node);
  if ($node->{expanded}) {
    for my $key (sort { $#{$node->{children}->{$b}->{games}}
                        <=> $#{$node->{children}->{$a}->{games}}
                      } keys %{$node->{children}}) {
      my $child = $node->{children}->{$key};
      splice @result, @result, 0, tree_get_visible_subtree($child);
    }
  }
  return @result;
}

# TODO do not expand leaf nodes!
sub tree_expand_node {
  my $i = shift;
  my $node = $TREE{list}->[$i];

  $node->{expanded} = 1;
  if (!defined($node->{children})) {
    tree_make_children $node;
  }
  my @vn = tree_get_visible_subtree $node;
  splice @{$TREE{list}}, $i, 1, @vn;
}

sub tree_collapse_node {
  my $i = shift;
  my $node = $TREE{list}->[$i];

  $node->{expanded} = 0;
  if ($i == $#{$TREE{list}}) { return }
  for ($j = $i+1;
       ($j < $#{$TREE{list}}) && ($TREE{list}->[$j]->{depth} > $node->{depth});
       $j++) {}
  splice @{$TREE{list}}, ($i+1), ($j-$i-1);
}

sub tree_correct_top {
  my ($maxy, $maxx);
  $TREE{win}->getmaxyx($maxy, $maxx);

  if ($TREE{sel} < $TREE{top}) {
    $TREE{top} = $TREE{sel};
  } elsif ($TREE{sel} >= $TREE{top}+$maxy) {
    $TREE{top} = $TREE{sel}-$maxy+1;
  }
}

sub tree_redraw {
  my $win = $TREE{win};
  my $i = 0;

  my ($maxy, $maxx);
  $win->getmaxyx($maxy, $maxx);

  $win->clear;
  for (my $i = 0; $i < $maxy; $i++) {
    my $node = $TREE{list}->[$TREE{top}+$i];
    my $shift = ($node->{depth}-1)*2;
    if ($TREE{top}+$i == $TREE{sel}) { $win->attron(A_REVERSE); }
    if ($shift + length($node->{text}) <= $maxx) {
      $win->addstring($i, $shift, $node->{text});
    } else {
      $win->addstring(
        $i, $shift, substr($node->{text}, 0, ($maxx-$shift-1)) . "+");
    }
    if ($TREE{top}+$i == $TREE{sel}) { $win->attroff(A_REVERSE); }
    last if ($TREE{top}+$i >= $#{$TREE{list}});
  }
  if (($BOARD) && ($BOARD->opened)) {
    print $BOARD $TREE{list}->[$TREE{sel}]->{pos}."\n";
  }
}

sub tree_keypress {
  my ($c, $key) = @_;
  if ($key == KEY_RESIZE) {
    tree_redraw;
  } elsif ($c eq 'g') {
    $TREE{sel} = 0;
    $TREE{top} = 0;
    tree_redraw;
  } elsif ($c eq 'G') {
    $TREE{sel} = $#{$TREE{list}};
    tree_correct_top;
    tree_redraw;
  } elsif (($c eq 'k') && ($TREE{sel} > 0)) {
    $TREE{sel}--;
    tree_correct_top;
    tree_redraw;
  } elsif (($c eq 'j') && ($TREE{sel} < $#{$TREE{list}})) {
    $TREE{sel}++;
    tree_correct_top;
    tree_redraw;
  } elsif ($c eq 'h') {
    my $node = $TREE{list}->[$TREE{sel}];
    if (($#{$node->{games}} > 0) && ($node->{expanded})) {
      tree_collapse_node $TREE{sel};
      tree_redraw;
    }
  } elsif ($c eq 'l') {
    my $node = $TREE{list}->[$TREE{sel}];
    if (($#{$node->{games}} > 0) && (!$node->{expanded})) {
      tree_expand_node $TREE{sel};
      tree_redraw;
    }
  } elsif ($c eq 'b') {
    if (($BOARD) && ($BOARD->opened)) {
      board_close;
    } else {
      board_open;
      tree_redraw;
    }
  } elsif ($c eq 'y') {
    yank $TREE{list}->[$TREE{sel}]->{pos};
  } elsif ($c eq "\n" || $c eq " ") {
    if ($#{$TREE{list}->[$TREE{sel}]->{games}} == 0) {
      my $game_idx = $TREE{list}->[$TREE{sel}]->{games}->[0];
      my $move = $TREE{list}->[$TREE{sel}]->{depth};
      game_show $TREE{win}, $game_idx, $move;
    } elsif ($TREE{list}->[$TREE{sel}]->{expanded}) {
      tree_collapse_node $TREE{sel};
    } else {
      tree_expand_node $TREE{sel};
    }
    tree_redraw;
  }
}

sub tree_show {
  my $win = shift;

  $TREE{win} = $win;
  if (!defined($TREE{root})) {
    tree_create;
  }
  tree_redraw;

  my ($c, $key);
  while (!($c eq 'q')) {
    ($c, $key) = $win->getchar();
    tree_keypress $c, $key;
  }
}

# LIST VIEW

sub list_correct_top {
  my $win = $LIST{win};

  my ($maxy, $maxx);
  $win->getmaxyx($maxy, $maxx);

  if ($LIST{sel} < $LIST{top}) {
    $LIST{top} = $LIST{sel};
  } elsif ($LIST{sel}-$LIST{top} >= $maxy) {
    $LIST{top} = $LIST{sel}-$maxy+1;
  }
}

sub list_redraw {
  my $win = $LIST{win};

  my ($maxy, $maxx);
  $win->getmaxyx($maxy, $maxx);

  $win->clear;
  $bottom = ($LIST{top}+$maxy < $#$GAMES ? $LIST{top}+$maxy : $#$GAMES);
  my $lines = format_list($LIST{top}, $bottom);
  for ($i = 0; $i <= $#$lines; $i++) {
    if ($LIST{top}+$i == $LIST{sel}) { $win->attron(A_REVERSE); }
    $win->addstring($i, 0, $lines->[$i]);
    if ($LIST{top}+$i == $LIST{sel}) { $win->attroff(A_REVERSE); }
  }
}

sub list_keypress {
  my ($c, $key) = @_;
  if ($key == KEY_RESIZE) {
    list_redraw;
  } elsif ($c eq 'g') {
    $LIST{sel} = 0;
    $LIST{top} = 0;
    list_redraw;
  } elsif ($c eq 'G') {
    $LIST{sel} = $#$GAMES;
    list_correct_top;
    list_redraw;
  } elsif (($c eq 'k') && ($LIST{sel} > 0)) {
    $LIST{sel}--;
    list_correct_top;
    list_redraw;
  } elsif (($c eq 'j') && ($LIST{sel} < $#$GAMES)) {
    $LIST{sel}++;
    list_correct_top;
    list_redraw;
  } elsif ($c eq "t") {
    tree_show $LIST{win};
    board_close_if_open;
    list_redraw;
  } elsif ($c eq "\n") {
    game_show $LIST{win}, $LIST{sel};
    board_close_if_open;
    list_redraw;
  }
}

sub list_show {
  my $win = shift;

  $LIST{win} = $win;
  list_redraw;

  my ($c, $key);
  while (!($c eq 'q')) {
    ($c, $key) = $win->getchar();
    list_keypress $c, $key;
  }
}

# MAIN BODY

my $win = new Curses;

initscr;
raw;
keypad($win, 1);
noecho();
curs_set(0);

start_color;
use_default_colors;

list_show $win;

curs_set(1);
endwin;

