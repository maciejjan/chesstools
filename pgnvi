#!/usr/bin/perl

use Curses;
use utf8;

use Chess::Rep;
use Chess::PGN::Parse;

our %GAME;
our $BOARD;

our %LIST = (
  sel => 0,
);

our @LIST_FIELDS = ("White", "Black", "Year", "Result", "ECO");

our $BOARDCMD = "perl drawboard";

$pgn = new Chess::PGN::Parse "$ARGV[0]"
  || die "Could not open file: $ARGV[0]";
$GAMES = $pgn->smart_read_all({save_comments => 'yes', comments_struct => 'array'});

# TODO (for v 0.1)
# - scrolling of the move list
# - variants
# - wrapping comments
# - editing comments with $EDITOR
# TODO: input -- two modes:
# - "normal" - input the fields like they are on the keyboard
# - "expert":
#   ASDFJKL: = ABCDEFGH
#   QWERUIOP = 12345678
#   CVBNM    = RNBQK
#   e.g. vje = Nf3
#        jr = e4
#        ju = e5
#        vdi = Nc6
# TODO views for browsing all games in the file
# - list view
#   - keybindings:
#     - k/j: go up/down
#     - t: switch to tree view
#   - data structure: list view
#     - current element
#     - top
#   - functions:
#     - list_show
#     - list_redraw
#     - list_keypress
# - tree view
#   - keybindings:
#     - k/j: go up/down
#     - h/l/<CR>: collapse/expand the current node
#     - p: go to parent node
#     - g: go to root
#     - c: collapse all except the path to current node
#     - t: switch to list view
#     - l/<CR>: open game
#     - v: toggle the board
#   - data structure: tree node:
#     - currently expanded?
#     - move number
#     - list of moves
#     - list of matching game IDs
#     - children (initially empty)
#   - data structure: tree view
#     - current 
#   - functions:
#     - tree_expand
#     - tree_make_children
#     - tree_show
#     - tree_redraw
#     - tree_keypress
# - game view
#   - keybindings:
#     - v: toggle the board
# FIXME bugs:
# - if a board window is closed, pgnvi still tries to write to the pipe and
#   crashes

sub format_game {
  my $game = shift;
  my $year = substr $game->{Date}, 0, 4;
  return $game->{White}." -- ".$game->{Black}." ($year) -- ".$game->{Result}." -- ".$game->{ECO};
}

sub get_field_for_game {
  my ($field, $idx) = @_;
  if ($field eq "Year") {
    return substr $GAMES->[$idx]->{Date}, 0, 4;
  } elsif ($field eq "keys") { # for debug purposes only
    return join(",",(keys %{$GAMES->[$idx]}));
  } elsif ($field eq "moves") { # for debug purposes only
    return join(",",@{$GAMES->[$idx]->{GameMoves}});
  } else {
    return $GAMES->[$idx]->{$field};
  }
}

sub format_list {
  my ($start, $end) = @_;

  $result = [];
  $fieldlen = ();
  for my $field (@LIST_FIELDS) {
    for (my $i = $start; $i <= $end; $i++) {
      my $l = length(get_field_for_game($field, $i));
      if ((!defined($fieldlen{$field})) || ($fieldlen{$field} < $l)) {
        $fieldlen{$field} = $l;
      }
    }
  }
  for (my $i = $start; $i <= $end; $i++) {
    my @str = ();
    for my $field (@LIST_FIELDS) {
      my $val = get_field_for_game($field, $i);
      push @str, $val;
      for (my $j = 0; $j < ($fieldlen{$field} - length $val)+2; $j++) {
        push @str, " ";
      }
    }
    push @$result, (join "", @str);
  }
  return $result;
}

# GAME VIEW

sub game_precompute_positions {
  my $moves = $GAMES->[$GAME{idx}]->{GameMoves};
  my $pos = new Chess::Rep;
  $GAME{positions} = [$pos->get_fen];
  for (my $i = 0; $i <= $#$moves; $i++) {
    $pos->go_move($moves->[$i]);
    push @{$GAME{positions}}, $pos->get_fen;
  }
}

sub game_draw_moves_list {
  my ($x1, $y1, $x2, $y2) = @_;

  my $moves = $GAMES->[$GAME{idx}]->{GameMoves};
  my $win = $GAME{win};
  my ($cx, $cy) = ($x1, $y1);

  my $last_move_idx = $#{$GAMES->[$GAME{idx}]->{GameMoves}}+1;
  $win->addstring(30, 0, "!".$GAME{move}."!".$last_move_idx);

  for (my $i = 0; $i <= $#$moves; $i++) {
    my $mn = int($i/2+1).".";
    if ($i % 2 == 0) {
      if ($cx + length("$mn $moves->[$i] $moves->[$i+1]") > $x2) {
        $cx = $x1;
        $cy++;
        last if $cy > $y2;
      }
      $win->addstring($cy, $cx, "$mn");
      $cx += length($mn) + 1;
    } 
    if ($i+1 == $GAME{move}) { $win->attron(A_REVERSE); }
    $win->addstring($cy, $cx, $moves->[$i]);
    $cx += length($moves->[$i]) + 1;
    if ($i+1 == $GAME{move}) { $win->attroff(A_REVERSE); }
  }
}

sub game_draw_comments {
  my ($x1, $y1, $x2, $y2) = @_;

  my $moves = $GAMES->[$GAME{idx}]->{GameMoves};

  my $cm2 = int($GAME{move}/2+0.5) . ($GAME{move} % 2 == 1 ? "w" : "b");
  if (defined($GAME{comments}->{$cm2})) {
    my $j = 0;
    for $c (@{$GAME{comments}->{$cm2}}) {
      $win->addstring($y1+$j, $x1, $c);
      $j++;
    }
  }
}

sub game_redraw {
  $GAME{win}->clear;
  game_draw_moves_list 0, 0, 40, 20;
  #game_draw_comments 0, 20, 40, 40;
  if (($BOARD) && ($BOARD->opened)) {
    print $BOARD $GAME{pos}->get_fen."\n";
  }
}

sub game_keypress {
  my ($c, $key) = @_;

  my $last_move_idx = $#{$GAMES->[$GAME{idx}]->{GameMoves}}+1;

  if ($c eq 'g') {
    $GAME{move} = 0;
    $GAME{pos}->set_from_fen($GAME{positions}->[$GAME{move}]);
    game_redraw;
  } elsif ($c eq 'G') {
    $GAME{move} = $last_move_idx;
    $GAME{pos}->set_from_fen($GAME{positions}->[$GAME{move}]);
    game_redraw;
  } elsif ($c eq 'j') {
    if ($GAME{move} < $last_move_idx) { $GAME{move}++; }
    $GAME{pos}->set_from_fen($GAME{positions}->[$GAME{move}]);
    game_redraw;
  } elsif ($c eq 'k') {
    if ($GAME{move} > 0) { $GAME{move}--; }
    $GAME{pos}->set_from_fen($GAME{positions}->[$GAME{move}]);
    game_redraw;
  } elsif ($c eq 'v') {
    if (($BOARD) && ($BOARD->opened)) {
      close $BOARD;
    } else {
      open $BOARD, "|-", $BOARDCMD;
      autoflush $BOARD 1;
      game_redraw;
    }
  }
}

sub game_show {
  my $win = shift;
  my $idx = shift;

  %GAME = (win => $win, idx => $idx, move => 0, board => 0, pos => new Chess::Rep);
  game_precompute_positions;
  game_redraw;

  my ($c, $key);
  while (!($c eq 'q')) {
    ($c, $key) = $win->getchar();
    game_keypress $c, $key;
  }
  if (($BOARD) && ($BOARD->opened)) {
    close $BOARD;
  }
}

# LIST VIEW

sub list_correct_top {
  my $win = $LIST{win};

  my ($maxy, $maxx);
  $win->getmaxyx($maxy, $maxx);

  if ($LIST{sel} < $LIST{top}) {
    $LIST{top} = $LIST{sel};
  } elsif ($LIST{sel}-$LIST{top} >= $maxy) {
    $LIST{top} = $LIST{sel}-$maxy+1;
  }
}

sub list_redraw {
  my $win = $LIST{win};

  my ($maxy, $maxx);
  $win->getmaxyx($maxy, $maxx);

  $win->clear;
  $bottom = ($LIST{top}+$maxy < $#$GAMES ? $LIST{top}+$maxy : $#$GAMES);
  my $lines = format_list($LIST{top}, $bottom);
  for ($i = 0; $i <= $#$lines; $i++) {
    if ($LIST{top}+$i == $LIST{sel}) { $win->attron(A_REVERSE); }
    $win->addstring($i, 0, $LIST{sel}." ".$#$GAMES." ".$lines->[$i]);
    if ($LIST{top}+$i == $LIST{sel}) { $win->attroff(A_REVERSE); }
  }
}

sub list_keypress {
  my ($c, $key) = @_;
  if ($c eq 'g') {
    $LIST{sel} = 0;
    $LIST{top} = 0;
    list_redraw;
  } elsif ($c eq 'G') {
    $LIST{sel} = $#$GAMES;
    list_correct_top;
    list_redraw;
  } elsif (($c eq 'k') && ($LIST{sel} > 0)) {
    $LIST{sel}--;
    list_correct_top;
    list_redraw;
  } elsif (($c eq 'j') && ($LIST{sel} < $#$GAMES)) {
    $LIST{sel}++;
    list_correct_top;
    list_redraw;
  } elsif ($c eq "\n") {
    game_show $LIST{win}, $LIST{sel};
    list_redraw;
  }
}

sub list_show {
  my $win = shift;

  $LIST{win} = $win;
  list_redraw;

  my ($c, $key);
  while (!($c eq 'q')) {
    ($c, $key) = $win->getchar();
    list_keypress $c, $key;
  }
}

my $win = new Curses;

initscr;
raw;
keypad($win, 1);
noecho();
curs_set(0);

start_color;
use_default_colors;

list_show $win;

curs_set(1);
endwin;

