#!/usr/bin/perl

use Curses;
use Try::Tiny;
use utf8;

use Chess::Rep;
use Chess::PGN::Parse;

our %GAME;
our $BOARD;

our %LIST = (
  sel => 0,
  top => 0,
);

our %TREE = (
  sel => 0,
  root => undef,
  list => undef,
);

our @LIST_FIELDS = ("No", "White", "Black", "Year", "Result", "ECO");

our $BOARDCMD = "drawboard";
our $YANKCMD = "xclip -i";

if (($#ARGV < 0) || ($ARGV[0] eq "-h") || ($ARGV[0] eq "--help")) {
  die "usage: pgnvi PGN_FILE";
}

our $FILENAME = $ARGV[0];

$pgn = new Chess::PGN::Parse "$FILENAME"
  || die "Could not open file: $FILENAME";
$GAMES = $pgn->smart_read_all();

# TODO (for v 0.2)
# - comments and variants
# - improvements in the tree view:
#   - compress nodes with only one child
# - list & tree view
#   - searching
#   - filtering
# - scrolling of the move list
# - editing comments with $EDITOR
# TODO metadata editing mode
# FIXME bugs:
# - if a board window is closed, pgnvi still tries to write to the pipe and
#   crashes

sub yank {
  my $arg = shift;
  if (open(my $pipe, "|-:encoding(UTF-8)", $YANKCMD)) {
    print $pipe $arg;
    close($pipe);
  }
}

sub number_moves {
  my $mn = 0;
  my @result = ();
  while (my $move = shift @_) {
    if ($mn % 2 == 0) {
      push @result, int($mn/2+1).".";
    }
    push @result, $move;
    $mn++;
  }
  return @result;
}

sub print_game {
  my $fh = shift;
  my $game = shift;
  for my $key (keys %$game) {
    if (($key =~ /^[A-Z].*/) && ($key !~ /Game.*/)) {
      print $fh "[$key \"$game->{$key}\"]\n";
    }
  }
  print $fh "\n";
  print $fh (join " ", number_moves(@{$game->{GameMoves}}))."\n\n";
}

sub save {
  my $filename = shift;
  open $fh, "+>", $filename;
  for my $game (@$GAMES) {
    print_game $fh, $game;
  }
  close $fh;
}

sub format_game {
  my $game = shift;
  my $year = substr $game->{Date}, 0, 4;
  return $game->{White}." — ".$game->{Black}." ($year) — ".$game->{Result};
}

sub get_field_for_game {
  my ($field, $idx) = @_;
  if ($field eq "Year") {
    return substr $GAMES->[$idx]->{Date}, 0, 4;
  } elsif ($field eq "No") {
    return $idx+1;
  } elsif ($field eq "keys") { # for debug purposes only
    return join(",",(keys %{$GAMES->[$idx]}));
  } elsif ($field eq "moves") { # for debug purposes only
    return join(",",@{$GAMES->[$idx]->{GameMoves}});
  } else {
    return $GAMES->[$idx]->{$field};
  }
}

sub format_list {
  my ($start, $end) = @_;

  $result = [];
  $fieldlen = ();
  for my $field (@LIST_FIELDS) {
    for (my $i = $start; $i <= $end; $i++) {
      my $l = length(get_field_for_game($field, $i));
      if ((!defined($fieldlen{$field})) || ($fieldlen{$field} < $l)) {
        $fieldlen{$field} = $l;
      }
    }
  }
  for (my $i = $start; $i <= $end; $i++) {
    my @str = ();
    for my $field (@LIST_FIELDS) {
      my $val = get_field_for_game($field, $i);
      push @str, $val;
      for (my $j = 0; $j < ($fieldlen{$field} - length $val)+2; $j++) {
        push @str, " ";
      }
    }
    push @$result, (join "", @str);
  }
  return $result;
}

# BOARD

sub board_open {
  open $BOARD, "|-", $BOARDCMD;
  autoflush $BOARD 1;
}

sub board_close {
  close $BOARD;
}

sub board_close_if_open {
  if (($BOARD) && ($BOARD->opened)) {
    board_close;
  }
}

# GAME VIEW

sub game_new_node {
  my ($move, $parent) = @_;
  my $node = {
    pos => undef,
    move => $move,
    mn => 0,
    prev => undef,
    next => undef,
    NAG => [],
    variants => [],
    comments => [],
  };
  if (defined($parent)) {
    $node->{prev} = $parent;
    $node->{pos} = new Chess::Rep($parent->{pos}->get_fen);
    $node->{pos}->go_move($move);
    $node->{mn} = $parent->{mn}+1;
  } else {
    $node->{pos} = new Chess::Rep;
    if (defined($move)) {
      $node->{pos}->go_move($move);
    }
  }
  return $node;
}

sub game_parse {
  my ($text, $parent) = @_;

  my $game = new Chess::PGN::Parse undef, $text;
  $game->read_game;
  $game->parse_game({save_comments => 'yes', comments_struct => 'hol'});
  my $moves = $game->moves;
  my $comments = $game->comments;

  my $root;
  if (!defined($parent)) {
    $root = game_new_node;
  } else {
    my $nextmove = shift @$moves;
    yank $parent->{pos}->get_fen;
    $root = game_new_node($nextmove, $parent);
  }

  my ($node, $prevnode) = ($root, undef);
  for (@$moves) {
    $prevnode = $node;
    $node = game_new_node $_, $prevnode;
    my $hmn = int($node->{mn}/2+0.5) . ($node->{mn} % 2 == 1 ? "w" : "b");
    if (defined($comments->{$hmn}->{NAG})) {
      $node->{NAG} = $comments->{$hmn}->{NAG};
    }
    if (defined($comments->{$hmn}->{RAV})) {
      for (@{$comments->{$hmn}->{RAV}}) {
        s/^\(//; s/\)$//;
        my $childnode = game_parse($_, $node->{prev});
        push @{$node->{variants}}, $childnode;
      }
    }
    if (defined($comments->{$hmn}->{brace})) {
      $node->{comments} = $comments->{$hmn}->{brace};
    }
    $prevnode->{next} = $node;
  }
  return $root;
}

sub game_listmoves {
  $GAME{movelist} = [];
  my $node = $GAME{movetree};
  while (defined($node)) {
    push @{$GAME{movelist}}, $node;
    $node = $node->{next};
  }
}

sub game_draw_header {
  my ($x1, $y1, $x2, $y2) = @_;
  my $win = $GAME{win};
  my @lines = ();

  my $game = $GAMES->[$GAME{idx}];
  my $white = $game->{White} .
              ($game->{WhiteTitle} ? " $game->{WhiteTitle}" : "") .
              ($game->{WhiteElo} ? " ($game->{WhiteElo})" : "");
  my $black = $game->{Black} .
              ($game->{BlackTitle} ? " $game->{BlackTitle}" : "") .
              ($game->{BlackElo} ? " ($game->{BlackElo})" : "");
  push @lines, "$white — $black";
  push @lines, "$game->{Event}" .
               ($game->{Round} ? " round $game->{Round}" : "");
  push @lines, "$game->{Site} $game->{Date}";
  push @lines, "$game->{ECO} $game->{Opening}";

  my $center = int(($x2-$x1)/2);
  $win->attron(A_BOLD);
  for (my $j = 0; $j <= $#lines; $j++) {
    $win->addstring($j, int($center-length($lines[$j])/2), $lines[$j]);
  }
  $win->attroff(A_BOLD);
}

sub game_draw_moves_list {
  my ($x1, $y1, $x2, $y2) = @_;

  my $win = $GAME{win};
  my ($cx, $cy) = ($x1, $y1);

  for (@{$GAME{movelist}}) {
    next if ($_->{mn} <= 0);
    my $mn = int(($_->{mn}+1)/2).".";
    if ($_->{mn} % 2 == 1) {
      if ($cx + length("$mn $_->{move} $_->{next}->{move}") > $x2) {
        $cx = $x1;
        $cy++;
        last if $cy > $y2;
      }
      $win->addstring($cy, $cx, "$mn");
      $cx += length($mn) + 1;
    } 
    if (($_ == $GAME{curmove}) && !defined($GAME{append})) {
      $win->attron(A_REVERSE);
    }
    $win->addstring($cy, $cx, $_->{move});
    $cx += length($_->{move}) + 1;
    if (($_ == $GAME{curmove}) && !defined($GAME{append})) {
      $win->attroff(A_REVERSE);
    }
  }
  # append mode cursor
  # TODO going to the next line if the text exceeds the line width
  if (defined($GAME{append})) {
    my $appendstr = $GAME{append} ? $GAME{append} : " ";
    my $nmoves = $#{$GAME{movelist}};
    if ($nmoves % 2 == 0) {
      $appendstr = int($nmoves/2+1). ". " . $appendstr;
    }
    $win->attron(A_REVERSE);
    $win->addstring($cy, $cx, $appendstr);
    $win->attroff(A_REVERSE);
    $cx += length($appendstr)+1;
  }
  # append the result to the moves list
  # TODO only if in main line!
  if (defined($GAMES->[$GAME{idx}]->{Result})) {
    my $result = $GAMES->[$GAME{idx}]->{Result};
    if ($cx + length($result) > $x2) { $cx = $x1; $cy++; }
    $win->addstring($cy, $cx, $result);
  }
  return $cy;
}

sub game_draw_variants {
  my ($x1, $y1, $x2, $y2) = @_;

  my $j = 0;
  for (@{$GAME{curmove}->{variants}}) {
    $GAME{win}->addstring($y1+$j++, $x1, $_->{move});
  }
  return $y1+$j;
}

sub game_draw_comments {
  my ($x1, $y1, $x2, $y2) = @_;

  $GAME{win}->addstring($y1-1, $x1, ":".$GAME{curmove}->{mn}." ".$GAME{curmove}->{move});
  my $j = 0;
  for (@{$GAME{curmove}->{comments}}) {
    s/^\{ ?//; s/ ?\}$//g;
    $GAME{win}->addstring($y1+$j++, $x1, $_);
  }
  return $y1+$j;
}

sub game_redraw {
  my ($maxy, $maxx);
  $GAME{win}->getmaxyx($maxy, $maxx);

  $GAME{win}->clear;

  game_draw_header 0, 0, $maxx, 5;
  my $y = game_draw_moves_list 0, 5, $maxx, 15;
  $y = game_draw_variants 0, ($y+2), $maxx, ($y+8);
  $y = game_draw_comments 0, ($y+2), $maxx, ($y+8);

  # print the position to the board
  if (($BOARD) && ($BOARD->opened)) {
    print $BOARD $GAME{curmove}->{pos}->get_fen."\n";
  }
}

sub game_append_keypress {
  my ($c, $key) = @_;

  if ($key == KEY_BACKSPACE) {
    $GAME{append} = substr $GAME{append}, 0, (length($GAME{append})-1);
    game_redraw;
  } elsif ($c eq "\n") {
    # exit the append mode
    undef $GAME{append};
    game_redraw;
  } elsif ($c =~ /[qweruiopasdfjkl;zxcvm,.\/=ntT]/) {
    $c =~ tr/qweruiopasdfjkl;zxcvm,.\/=ntT/12345678abcdefghRNBQKBNR=x+#/;
    $GAME{append} .= $c;
    game_redraw;
  } elsif ($c eq 'y') {
    $GAME{append} .= "O-O";
    game_redraw;
  } elsif ($c eq 'Y') {
    $GAME{append} .= "O-O-O";
    game_redraw;
  } elsif ($c eq ' ') {
    # try adding the currently appended move
    try {
      my $lastnode = $GAME{movelist}->[$#{$GAME{movelist}}];
      my $node = game_new_node($GAME{append}, $lastnode);
      $lastnode->{next} = $node;
      push @{$GAME{movelist}}, $node;
      $GAME{append} = "";
      $GAME{curmove} = $node;
    };
    game_redraw;
  }
}

sub game_keypress {
  my ($c, $key) = @_;

  my $last_move_idx = $#{$GAMES->[$GAME{idx}]->{GameMoves}}+1;

  if (defined $GAME{append}) {
    game_append_keypress $c, $key;
  } elsif ($key == KEY_RESIZE) {
    game_redraw;
  } elsif ($c eq 'g') {
    $GAME{curmove} = $GAME{movelist}->[0];
    game_redraw;
  } elsif ($c eq 'G') {
    $GAME{curmove} = $GAME{movelist}->[$#{$GAME{movelist}}];
    game_redraw;
  } elsif (($c eq 'j') && (defined($GAME{curmove}->{next}))) {
    $GAME{curmove} = $GAME{curmove}->{next};
    game_redraw;
  } elsif (($c eq 'k') && (defined($GAME{curmove}->{prev}))) {
    $GAME{curmove} = $GAME{curmove}->{prev};
    game_redraw;
  } elsif ($c eq 'a') {
    # enter the append mode
    $GAME{append} = "";
    push @{$GAME{changes}}, { at => $GAME{curmove}, deleted => undef };
    game_redraw;
  } elsif ($c eq 'A') {
    # delete everything behind the cursor and enter the append mode
    $GAME{curmove}->{next} = undef;
    $GAME{append} = "";
    push @{$GAME{changes}},
         { at => $GAME{curmove}, deleted => $GAME{curmove}->{next} };
    game_listmoves;
    game_redraw;
  } elsif ($c eq 'u') {
    # undo the last append
    if (length @{$GAME{changes}} > 0) {
      my $change = pop @{$GAME{changes}};
      $change->{at}->{next} = $change->{deleted};
      $GAME{curmove} = $change->{at};
      game_listmoves;
      game_redraw;
    }
  } elsif ($c eq 'b') {
    if (($BOARD) && ($BOARD->opened)) {
      board_close;
    } else {
      board_open;
      game_redraw;
    }
  } elsif ($c eq 'y') {
    yank $GAME{curmove}->{pos}->get_fen;
  } elsif ($c eq 's') {
    save $FILENAME;
  }
}

sub game_show {
  my $win = shift;
  my $idx = shift;
  my $move_idx = shift;

  if (!defined($move_idx)) { $move = 0; }
  %GAME = (
    win => $win, idx => $idx, move => undef, board => 0,
    append => undef, changes => [], comments => undef);
  $GAME{movetree} = game_parse $GAMES->[$idx]->{Game}, undef, 0;
  game_listmoves;
  $GAME{curmove} = $GAME{movelist}->[$move_idx];
  game_redraw;

  my ($c, $key);
  while (!($c eq 'q') || (defined $GAME{append})) {
    ($c, $key) = $win->getchar();
    game_keypress $c, $key;
  }
}

# TREE VIEW

sub tree_make_children {
  my $node = shift;

  my %illegal = ();

  # create the child nodes
  $node->{children} = {};
  my $pos = new Chess::Rep;
  for my $idx (@{$node->{games}}) {
    my $move = $GAMES->[$idx]->{GameMoves}->[$node->{depth}];
    if ((!defined($node->{children}->{$move}))
       && (!defined($illegal{$move}))) {
      try {
        $pos->set_from_fen($node->{pos});
        $pos->go_move($move);
        $node->{children}->{$move} = {
          expanded => 0, depth => $node->{depth}+1, games => [],
          children => undef, text => undef, pos => $pos->get_fen
        }
      } catch {
        $illegal{$move} = 1;
      }
    }
    if (defined($node->{children}->{$move})) {
      push @{$node->{children}->{$move}->{games}}, $idx;
    }
  }
  # add the text descriptions of the nodes (like e.g. "+ 1. ..e6 (10)")
  for my $key (keys %{$node->{children}}) {
    $n = $#{$node->{children}->{$key}->{games}}+1;
    my $child = $node->{children}->{$key};
    my $mn = int(($child->{depth}+1)/2);
    my $mt = "$mn. ".($child->{depth} % 2 == 0 ? ".." : "") . $key;
    if ($n > 1) {
      $child->{text} = "+ $mt ($n)";
    } else {
      my $game = $GAMES->[$child->{games}->[0]];
      $child->{text} = "* $mt: " . format_game $game;
    }
  }
}

sub tree_create {
  my $root = {
    expanded => 1, depth => 0, games => [], children => undef,
    pos => "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1",
  };
  for ($i = 0; $i <= $#$GAMES; $i++) {
    push @{$root->{games}}, $i;
  }
  tree_make_children $root;
  $TREE{root} = $root;

  $TREE{list} = [];
  for my $key (sort { $#{$root->{children}->{$b}->{games}}
                      <=> $#{$root->{children}->{$a}->{games}}
                    } keys %{$root->{children}}) {
    push @{$TREE{list}}, $root->{children}->{$key};
  }
}

sub tree_get_visible_subtree {
  my $node = shift;
  my @result = ($node);
  if ($node->{expanded}) {
    for my $key (sort { $#{$node->{children}->{$b}->{games}}
                        <=> $#{$node->{children}->{$a}->{games}}
                      } keys %{$node->{children}}) {
      my $child = $node->{children}->{$key};
      splice @result, @result, 0, tree_get_visible_subtree($child);
    }
  }
  return @result;
}

# TODO do not expand leaf nodes!
sub tree_expand_node {
  my $i = shift;
  my $node = $TREE{list}->[$i];

  $node->{expanded} = 1;
  if (!defined($node->{children})) {
    tree_make_children $node;
  }
  my @vn = tree_get_visible_subtree $node;
  splice @{$TREE{list}}, $i, 1, @vn;
}

sub tree_collapse_node {
  my $i = shift;
  my $node = $TREE{list}->[$i];

  $node->{expanded} = 0;
  if ($i == $#{$TREE{list}}) { return }
  for ($j = $i+1;
       ($j < $#{$TREE{list}}) && ($TREE{list}->[$j]->{depth} > $node->{depth});
       $j++) {}
  splice @{$TREE{list}}, ($i+1), ($j-$i-1);
}

sub tree_correct_top {
  my ($maxy, $maxx);
  $TREE{win}->getmaxyx($maxy, $maxx);

  if ($TREE{sel} < $TREE{top}) {
    $TREE{top} = $TREE{sel};
  } elsif ($TREE{sel} >= $TREE{top}+$maxy) {
    $TREE{top} = $TREE{sel}-$maxy+1;
  }
}

sub tree_redraw {
  my $win = $TREE{win};
  my $i = 0;

  my ($maxy, $maxx);
  $win->getmaxyx($maxy, $maxx);

  $win->clear;
  for (my $i = 0; $i < $maxy; $i++) {
    my $node = $TREE{list}->[$TREE{top}+$i];
    my $shift = ($node->{depth}-1)*2;
    if ($TREE{top}+$i == $TREE{sel}) { $win->attron(A_REVERSE); }
    if ($shift + length($node->{text}) <= $maxx) {
      $win->addstring($i, $shift, $node->{text});
    } else {
      $win->addstring(
        $i, $shift, substr($node->{text}, 0, ($maxx-$shift-1)) . "+");
    }
    if ($TREE{top}+$i == $TREE{sel}) { $win->attroff(A_REVERSE); }
    last if ($TREE{top}+$i >= $#{$TREE{list}});
  }
  if (($BOARD) && ($BOARD->opened)) {
    print $BOARD $TREE{list}->[$TREE{sel}]->{pos}."\n";
  }
}

sub tree_keypress {
  my ($c, $key) = @_;
  if ($key == KEY_RESIZE) {
    tree_redraw;
  } elsif ($c eq 'g') {
    $TREE{sel} = 0;
    $TREE{top} = 0;
    tree_redraw;
  } elsif ($c eq 'G') {
    $TREE{sel} = $#{$TREE{list}};
    tree_correct_top;
    tree_redraw;
  } elsif (($c eq 'k') && ($TREE{sel} > 0)) {
    $TREE{sel}--;
    tree_correct_top;
    tree_redraw;
  } elsif (($c eq 'j') && ($TREE{sel} < $#{$TREE{list}})) {
    $TREE{sel}++;
    tree_correct_top;
    tree_redraw;
  } elsif ($c eq 'h') {
    my $node = $TREE{list}->[$TREE{sel}];
    if (($#{$node->{games}} > 0) && ($node->{expanded})) {
      tree_collapse_node $TREE{sel};
      tree_redraw;
    }
  } elsif ($c eq 'l') {
    my $node = $TREE{list}->[$TREE{sel}];
    if (($#{$node->{games}} > 0) && (!$node->{expanded})) {
      tree_expand_node $TREE{sel};
      tree_redraw;
    }
  } elsif ($c eq 'b') {
    if (($BOARD) && ($BOARD->opened)) {
      board_close;
    } else {
      board_open;
      tree_redraw;
    }
  } elsif ($c eq 'y') {
    yank $TREE{list}->[$TREE{sel}]->{pos};
  } elsif ($c eq "\n" || $c eq " ") {
    if ($#{$TREE{list}->[$TREE{sel}]->{games}} == 0) {
      my $game_idx = $TREE{list}->[$TREE{sel}]->{games}->[0];
      my $move = $TREE{list}->[$TREE{sel}]->{depth};
      game_show $TREE{win}, $game_idx, $move;
    } elsif ($TREE{list}->[$TREE{sel}]->{expanded}) {
      tree_collapse_node $TREE{sel};
    } else {
      tree_expand_node $TREE{sel};
    }
    tree_redraw;
  }
}

sub tree_show {
  my $win = shift;

  $TREE{win} = $win;
  if (!defined($TREE{root})) {
    tree_create;
  }
  tree_redraw;

  my ($c, $key);
  while (!($c eq 'q')) {
    ($c, $key) = $win->getchar();
    tree_keypress $c, $key;
  }
}

# LIST VIEW

sub list_correct_top {
  my $win = $LIST{win};

  my ($maxy, $maxx);
  $win->getmaxyx($maxy, $maxx);

  if ($LIST{sel} < $LIST{top}) {
    $LIST{top} = $LIST{sel};
  } elsif ($LIST{sel}-$LIST{top} >= $maxy) {
    $LIST{top} = $LIST{sel}-$maxy+1;
  }
}

sub list_redraw {
  my $win = $LIST{win};

  my ($maxy, $maxx);
  $win->getmaxyx($maxy, $maxx);

  $win->clear;
  $bottom = ($LIST{top}+$maxy < $#$GAMES ? $LIST{top}+$maxy : $#$GAMES);
  my $lines = format_list($LIST{top}, $bottom);
  for ($i = 0; $i <= $#$lines; $i++) {
    if ($LIST{top}+$i == $LIST{sel}) { $win->attron(A_REVERSE); }
    $win->addstring($i, 0, $lines->[$i]);
    if ($LIST{top}+$i == $LIST{sel}) { $win->attroff(A_REVERSE); }
  }
}

sub list_keypress {
  my ($c, $key) = @_;
  if ($key == KEY_RESIZE) {
    list_redraw;
  } elsif ($c eq 'g') {
    $LIST{sel} = 0;
    $LIST{top} = 0;
    list_redraw;
  } elsif ($c eq 'G') {
    $LIST{sel} = $#$GAMES;
    list_correct_top;
    list_redraw;
  } elsif (($c eq 'k') && ($LIST{sel} > 0)) {
    $LIST{sel}--;
    list_correct_top;
    list_redraw;
  } elsif (($c eq 'j') && ($LIST{sel} < $#$GAMES)) {
    $LIST{sel}++;
    list_correct_top;
    list_redraw;
  } elsif ($c eq "t") {
    tree_show $LIST{win};
    board_close_if_open;
    list_redraw;
  } elsif ($c eq "\n") {
    game_show $LIST{win}, $LIST{sel};
    board_close_if_open;
    list_redraw;
  }
}

sub list_show {
  my $win = shift;

  $LIST{win} = $win;
  list_redraw;

  my ($c, $key);
  while (!($c eq 'q')) {
    ($c, $key) = $win->getchar();
    list_keypress $c, $key;
  }
}

# MAIN BODY

my $win = new Curses;

initscr;
raw;
keypad($win, 1);
noecho();
curs_set(0);

start_color;
use_default_colors;

list_show $win;

curs_set(1);
endwin;

